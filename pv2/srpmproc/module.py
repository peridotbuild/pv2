# -*-:python; coding:utf-8; -*-
# author: Louis Abel <label@resf.org>
"""
Module Import operations
"""

import sys
import datetime
import re
from functools import cached_property
import yaml
from pathlib import Path
from pv2.util import log as pvlog
from pv2.util import gitutil, fileutil, decorators
from pv2.util import error as err
from pv2.importer.operation import Import,GitHandler

# Clone source and destination
# Slurp the source yaml
# Identify every package into a list
# Check each package to see if they have a destination branch
#    -> The exception to this rule could be rpm-local-generator-support?
# If there is no dest branch, fail
# If there are dest branches for each, identify their commits and replace them
#    -> allow option of "branch name only" to avoid processing the above
#       this way it just replaces the ref with the new branch name
# in the dict
# export yaml to new file
# commit and push
# commit should allow empty no matter what

__all__ = ['ModuleImport']

# pylint: disable=too-many-arguments,too-many-positional-arguments,too-many-locals
# pylint: disable=broad-exception-caught,unspecified-encoding,line-too-long

class ModuleImport(Import):
    """
    Import class for importing a module via git
    """
    def __init__(
            self,
            module: str,
            stream: str,
            release: str,
            source_git_host: str,
            dest_git_host: str,
            source_branch=None,
            dest_branch=None,
            source_git_protocol: str = 'https',
            source_git_user: str = 'git',
            dest_git_user: str = 'git',
            dest_git_protocol: str = 'ssh',
            source_org: str = 'src-modules',
            dest_org: str = 'modules',
            rpm_org: str = 'rpms',
            source_branch_prefix: str = 'c',
            source_branch_suffix: str = '',
            dest_branch_prefix: str = 'r',
            dest_branch_suffix: str = '',
            overwrite_tags: bool = False,
            branch_name_refs: bool = True
    ):
        """
        Rev up the importer for srpmproc (modules)
        """
        # I *should* be able to simplify this somehow
        super().__init__(
                _package=module,
                _release=release,
                _source_git_protocol=source_git_protocol,
                _source_git_user=source_git_user,
                _source_git_host=source_git_host,
                _source_org=source_org,
                _source_branch=source_branch,
                _dest_git_host=dest_git_host,
                _dest_git_user=dest_git_user,
                _dest_org=dest_org,
                _dest_branch=dest_branch,
                _dest_git_protocol=dest_git_protocol,
                _overwrite_tags=overwrite_tags,
        )
        self.__module_name = module
        self.__rpm_org = rpm_org
        self.__branch_names_only = branch_name_refs
        self.__datestamp = datetime.datetime.utcnow().strftime('%Y%m%d%H%M%S')
        self.__version = f'{release}{self.__datestamp}'

        # if the branches are not autogenerated, they MUST be stream in them
        if source_branch and 'stream' not in source_branch:
            raise err.ConfigurationError('Modules must have "stream" in its branch')

        if dest_branch and 'stream' not in dest_branch:
            raise err.ConfigurationError('Modules must have "stream" in its branch')

        #branch_regex_groups = self.get_module_regex_groups(source_branch)
        self.__stream = stream
        self.__stream_name = stream

        # Determine branch stuff here
        if not source_branch:
            self._source_branch = f'{source_branch_prefix}{release}{source_branch_suffix}-stream-{stream}'
        if not dest_branch:
            self._dest_branch = f'{dest_branch_prefix}{release}{dest_branch_suffix}-stream-{stream}'

        self.__modulemd_file = f'{self.source_clone_path}/{self.module_name}.yaml'

        self.git = GitHandler(self)

    def __check_component_rpm(self, rpm):
        """
        Checks if a component RPM exists with its branch
        """
        git_url = self.build_git_url(
                protocol=self.dest_git_protocol,
                user=self.dest_git_user,
                host=self.dest_git_host,
                org=self.rpm_org,
                package=rpm
        )
        try:
            check_dest_repo = gitutil.lsremote(git_url)
        except err.GitInitError:
            pvlog.logger.exception(
                    'Git repo for %s does not exist at the source',
                    rpm)
            sys.exit(2)
        except Exception as exc:
            pvlog.logger.warning('An unexpected issue occurred: %s', exc)
            sys.exit(2)

        pvlog.logger.info('Checking if source branch exists: %s',
                          self.dest_branch)
        try:
            gitutil.ref_check(check_dest_repo, self.dest_branch)
        except err.GitCheckoutError as exc:
            pvlog.logger.error('Branch does not exist: %s', exc)
            sys.exit(2)

        return check_dest_repo

    def __modify_data(self, yaml_file):
        """
        Modify module data
        """
        path_to_yaml = f'{self.source_clone_path}/{yaml_file}'
        path_to_incr = f'{self.dest_clone_path}/date'
        with open(path_to_yaml, 'r') as module_yaml:
            content = yaml.safe_load(module_yaml)
            module_yaml.close()

        for k in content['data']['components']['rpms']:
            comp = self.__check_component_rpm(k)
            #content['data']['components']['rpms'][k]['ref'] = comp[f'refs/heads/{self.dest_branch}']
            #if self.branch_names_only:
            #    content['data']['components']['rpms'][k]['ref'] = self.dest_branch

        with open(path_to_yaml, 'r') as module_yaml:
            content = module_yaml.read()
            content_new = re.sub(r'ref:\s+(.*)', f'ref: {self.dest_branch}', content)
            module_yaml.close()

        # Write to the root
        with open(f'{self.dest_clone_path}/{self.module_name}.yaml', 'w') as module_yaml:
            module_yaml.write(content_new)
            module_yaml.close()

        with open(path_to_incr, 'w') as fp:
            fp.write(self.datestamp)
            fp.close()

        # Write to the root
        #with open(f'{self.dest_clone_path}/{self.module_name}.yaml', 'w') as module_yaml:
        #    module_yaml.write(content_new)
        #    module_yaml.close()

    # functions
    def srpmproc_import(self):
        """
        Imports the module
        """
        fault = 0
        result_dict = {}
        try:
            _source, _source_tag, _yaml = self.git.clone_source_module()
            _dest = self.git.clone_dest()

            # Remove everything from the destination, copy, and patch
            pvlog.logger.info('Copying module data')
            self.remove_everything(_dest.working_dir)
            self.copy_everything(_source.working_dir, _dest.working_dir)

            # perform yaml changes here
            self.__modify_data(_yaml)
            # also check for an "increment" file, create one if necessary

            # Get the NSVC
            nsvc_dict = self.split_nsvc_from_tag(str(_source_tag))
            print(nsvc_dict)
            nsvc = f"{self.module_name}-{self.stream_name}-{self.version}.{self._release}"
            svc_dict = nsvc_dict.copy()
            del svc_dict['module']

            # commit, tag, push
            msg = f'import {nsvc}'
            pvlog.logger.info('Importing: %s', nsvc)
            commit_res, commit_hash, commit_ref = self.git.commit_and_tag(_dest, msg, nsvc, False, self.overwrite_tags)

            if commit_res:
                self.git.push_changes(_dest, commit_ref, self.overwrite_tags)

            result_dict = self.set_import_metadata(
                    commit_hash,
                    svc_dict,
                    'Direct Git Import'
            )

        except (err.ConfigurationError, err.FileNotFound,
                err.TooManyFilesError, err.NotAppliedError,
                err.PatchConfigTypeError, err.PatchConfigValueError,
                err.GitInitError, err.GitApplyError) as exc:
            pvlog.logger.error('%s', exc)
            fault = exc.fault_code
        except Exception as exc:
            pvlog.logger.error('An unexpected error occurred.')
            pvlog.logger.exception('%s', exc)
            fault = 2
        else:
            pvlog.logger.info('Completed')
        finally:
            self.perform_cleanup([self.source_clone_path,
                                  self.dest_clone_path,
                                  self.dest_patch_clone_path])

        if fault > 0:
            sys.exit(fault)

        # return data
        return result_dict

    # pylint: disable=unused-argument
    @decorators.alias_for("srpmproc_import", warn=True)
    def pkg_import(self, *args, **kwargs):
        """
        This function is useless here.
        """
        return NotImplemented

    # properties
    @property
    def module_name(self):
        """
        What's the module name?
        """
        return self.__module_name

    @property
    def rpm_org(self):
        """
        The org where the RPM's are
        """
        return self.__rpm_org

    @property
    def rpm_name(self):
        """
        Returns the name of the RPM we're working with
        """
        return self.__module_name

    @property
    def rpm_name_replace(self):
        """
        Returns the name of the RPM we're working with
        """
        new_name = self.__module_name.replace('+', 'plus')
        return new_name

    @property
    def modulemd_file(self):
        """
        Returns the module name
        """
        return self.__modulemd_file

    @property
    def stream_name(self):
        """
        Returns the stream name
        """
        return self.__stream

    @property
    def branch_names_only(self):
        """
        Returns if we're using branch names only for refs
        """
        return self.__branch_names_only

    @cached_property
    def datestamp(self):
        """
        Returns a date time stamp
        """
        return self.__datestamp

    @cached_property
    def version(self):
        """
        Returns a date time stamp
        """
        return self.__version
